# Глава 3. Внедрение и развитие каркаса ИСУП



## Уточнение требований на основе результатов анализа

Разработанный инструмент сбора и анализа статистики пользовательских запросов для существующей ИСУП позволяет проверить гипотезы, которые помогут уточнить требования к функциям и технической реализации ИСУП:

*1. Функции чтения данных выполняются в 3 раза чаще функции записи, изменения и удаления данных.*

Проверка этой гипотезы позволяет определить, для каких функций при работе с данными должна быть оптимизирована система хранения и обработки данных. Если гипотеза подтверждается, то необходима оптимизация для частых операций чтения. Если гипотеза опровергается, то необходима оптимизация для частых операций записи, изменения и удаления данных. Число 3 выбрано потому, что скорость поиска записи по индексу GIN в 3 раза выше скорости поиска по индексу GiST, а скорость создания, обновления и удаления значения в индексе GIN в 3 раза ниже, чем в индексе GiST (в СУБД PostgreSQL); в данном случае GIN и GiST индексы являются примерами технически похожих решений, оптимизированных для разных функций [cite: pgsql-gin-gist].
#cite pgsql-gin-gist: PostgreSQL: Documentation: 9.1: GiST and GIN Index Types [Электронный ресурс]. URL: http://www.postgresql.org/docs/9.1/static/textsearch-indexes.html (дата обращения: 11.11.2015).

*2. Действия пользователей, имеющих сопоставимые роли в организации (исполнитель, функциональный руководитель, руководитель проекта, руководитель проектного офиса, директор), очень похожи между собой и имеют мало общего с действиями пользователей с другими ролями.*

Для проверки этой гипотезы необходимо собрать список запросов, сгруппировать по пользователям и кластеризовать его по функциям ИСУП. При этом известны роли пользователей. Допущения: на наборе данных определяется только одна роль для каждого пользователя, количество кластеров равно количеству групп пользователей по ролям. Гипотеза будет считаться верной, если список пользователей, связанных с каждым кластером пользовательских запросов, более, чем на половину, совпадает со списком пользователей, объединённых в группы по ролям.

Если гипотеза подтверждается, то необходима подстройка интерфейса ИСУП под роль пользователя.
Если гипотеза опровергается, то интерфейс ИСУП должен быть унифицированным для различных ролей пользователей.

*3. Возможно выделить группы подсистем, каждой из которых часто пользуются определённые группы людей и редко пользуются остальные.*

Если гипотеза подтверждается, то необходимо иметь возможность создать отдельные приложения (взаимодействующие между собой при необходимости) по каждой группе подсистем, которыми пользуются только некоторые определённые группы людей, что в дальнейшем позволит развивать и поддерживать эти приложения несколькими подразделениями или отдельными сотрудниками, а также снизит сложность и сузит круг решаемых приложениями задач, повысит их качество.

Если гипотеза опровергается, то нет необходимости разделять ИСУП на несколько приложений.

Проверка всех гипотез проводится на тестовом наборе данных, приведённом в источнике [cite: log-test-data].

Проверка **первой гипотезы** основывается на подсчёте количества запросов чтения данных, с одной стороны, и количества запросов записи, изменения и удаления данных, с другой стороны. При этом рассматриваются запросы в целом, без выделения конкретных операций СУБД, хранящей пользовательские запросы. Каждый запрос может приводить к выполнению нескольких различных операций СУБД. Redmine использует принцип RESTful, согласно которому запросы, выполняемые с помощью метода GET, не должны менять содержимое ресурса, к которому направлен запрос; для создания ресурса используется метод POST, для изменения -- PATCH (изменение только части ресурса) или PUT (замена ресурса целиком на основе значений, переданных в запросе), а для удаления -- метод DELETE [cite: rails-routing]. Поскольку Redmine Log сохраняет название метода запроса, то возможно произвести необходимые расчёты с помощью следующего кода:
#cite rails-routing: Rails Routing from the Outside In — Ruby on Rails Guides [Электронный ресурс]. URL: http://guides.rubyonrails.org/routing.html (дата обращения: 11.11.2015).

    method_count = Log.select(:http_method).group(:http_method).count
    read_count = method_count['GET']
    modify_methods = method_count.slice('POST', 'PUT', 'PATCH', 'DELETE')
    modify_count = modify_methods.reduce(0) { |a, e| a+e[1] }
    puts "Чтение: #{read_count}", "Запись, удаление и изменение: #{modify_count}"
    puts "Запросов на чтение в #{read_count.to_f / modify_count} раз больше"

Результат выполнения этого кода: 28533 запросов на чтение, 5928 запросов записи, изменения и удаления данных, запросов на чтение в 4,8 раз больше. **Первая гипотеза подтверждена.**

Для проверки **второй гипотезы** требуется подготовить два набора данных:

- список пользователей, сгруппированный по ролям;
- матрица использования функций, содержащая количество запросов каждого пользователя по каждой функции Redmine, причём каждая строка матрицы связана с одним пользователем.

Кластеризация матрицы использования функций проводится со следующими параметрами:

- количество кластеров равно количеству ролей, которые есть у рассматриваемых пользователей;
- для измерения расстояния между элементами и центрами кластеров предлагается использовать евклидово расстояние или квадрат евклидова расстояния;
- расстояние между кластерами определяется как расстояние между их центрами (взвешенный центроидный метод), поскольку предполагаются значительные отличия в размерах кластеров [cite: cluster-methods].
#cite cluster-methods: Кластерный анализ [Электронный ресурс]. URL: http://statsoft.ru/home/textbook/modules/stcluan.html (дата обращения: 21.11.2015).

Проверка корректности выделения кластеров заключается в проведении кластеризации с использованием:

- манхэттенского расстояния и взвешенного центроидного метода;
- манхэттенского расстояния и взвешенного попарного среднего;
- евклидового расстояния или квадрата евклидова расстояния и взвешенного попарного среднего.

Для кластеризации по центроидному методу используется алгоритм KMeans [cite: ai4r], по попарному среднему -- AverageLinkage [Там же], расширенные для поддержки весовых коэффициентов при измерении расстояний между кластерами. После кластеризации каждому элементу каждого кластера ставится в соответствие идентификатор пользователя, в результате получается список групп пользователей. Далее этот список сравнивается со списком пользователей, сгруппированным по должности: выявляются наиболее похожие группы между этими списками. Если не удаётся найти для группы из одного списка соответствующую группу из другого списка, то рассматриваемая гипотеза опровергается. Критерий сходства допускает небольшие различия (см. таблицу 1). Под различием понимается количество элементов кластера, которых нет в другом кластере.

При _size_ = 1, _maximum_deviation_ = 0,  
иначе _maximum_deviation_ = _size_ / 4 с округлением в бо́льшую сторону,  
где _maximum_deviation_ - допустимые различия, _size_ - размер кластера.

<p class="before_table_caption"></p>

Таблица 1. Допустимые различия кластеров, при которых кластеры считаются похожими

<p class="no-borders"></p>

| | |
---|---
Размер кластера         | 1 | 2 | 3 | 4 | 5 | ... | 20 | ...
Допустимые различия | 0 | 1 | 1 | 1 | 2 | ... |  5  | ...

    # people_by_job: список пользователей, сгруппированных
    # по должностям, hash {"Должность" => [user_id, ...]}.
    people_by_job = User.group_by_job
    clusters_count = people_by_job.size
    clusterer_options = LogPlugin::Analysis::ClustererWrapper::UserSegments.new(clusters_count: clusters_count)
    
    # Способы измерения расстояний между элементами расстояний.
    vectors_distance_methods = [
      -> (a, b) { Ai4r::Data::Proximity.squared_euclidean_distance(a, b) },
      -> (a, b) { Ai4r::Data::Proximity.manhattan_distance(a, b) }
    ]
    # Способы измерения расстояний между кластерами:
    # центроидный (KMeans) и попарный средний (AverageLinkage).
    clusters_distance_methods = [:weighted_centroid, :weighted_average]
    
    # users_clusters: для сравнения результатов кластеризации с разными параметрами.
    users_clusters = []
    vectors_distance_methods.each do |vd|
      clusterer_options.vectors_distance_method = vd
      clusters_distance_methods.each do |cd|
        clusterer_options. clusters_distance_method = cd
        
        # Результаты кластеризации сохраняются в clusterer_options.
        Log.analysis.user_segments(clusterer_options)
        users_clusters << clusterer_options.users_clusters
      end
    end
    
    puts "Количество вариантов кластеризации: #{users_clusters.uniq.size}"

Получился 1 вариант результатов кластеризации, т. е. при всех наборах заданных параметров получено одинаковое разбиение множества данных на кластеры.

    # people_by_cluster: array [[user_id, ...], ...].
    people_by_cluster = users_clusters[0]
    # conformity: соответствие [{a: индекс из первого аргумента, b: индекс из второго аргумента}, ...].
    conformity = LogPlugin::Analysis::Groups.compare_arrays_of_groups(people_by_job.values, people_by_cluster)
    
    # Если удалось найти соответствие между всеми группами,
    # то количество элементов в conformity должно быть равным clusters_count.
    success = conformity.size == clusters_count

В ходе проверки не было обнаружено соответствие между двумя списками групп пользователей -- между группами, составленными по должностям сотрудников и определёнными по кластеризации пользовательских запросов. Однако можно попытаться другими способами выразить роли сотрудников в организации, сгруппировать по ним пользователей и сравнить с группами, полученными в результате кластеризации. Например, определить роль каждого пользователя в организации по его ролям в проектах, в которых он участвует.

    # Определить, какие роли чаще всего встречаются у пользователей в каждом кластере.
    roles = Array.new(people_by_cluster.size) { Hash.new_with_default(0) }
    people_by_cluster.each_with_index do |group_cluster, cluster_index|
      member_ids = Member.where(user_id: group_cluster).pluck(:id)
      MemberRole.where(member_id: member_ids).each do |member_role|
        roles[cluster_index][member_role.role_id] += 1
      end
    end
    
    # Выделить три роли в проектах, которые чаще всего встречаются у пользователей в кластере.
    roles.map! { |roles_in_cluster| roles_in_cluster.sort_by { |role, count| -count }[0..2].map(&:first) }
    
    # Определить, у кого есть набор выделенных ролей в roles.
    people_by_roles = roles.map do |r|
      # mm: у кого есть этот набор ролей.
      mm = Member.joins(:member_roles).where(member_roles: {role_id: r}).group_by(&:user_id)
      # Выбираем тех пользователей, у которых есть все роли из набора.
      mm.select! do |user_id, members|
        role_ids = MemberRole.where(member_id: members.pluck(:id)).pluck(:role_id)
        #role_ids = members.map { |member| member.member_roles.map(&:role_id) }.flatten
        (role_ids & r).size == r.size
      end
      mm.map(&:first)
    end
    
    # Теперь сравним группы people_by_roles с группами people_by_cluster
    conformity = LogPlugin::Analysis::Groups.compare_arrays_of_groups(people_by_roles, people_by_cluster)
    # Если удалось найти соответствие между всеми группами,
    # то количество элементов в conformity должно быть равным clusters_count.
    success = conformity.size == clusters_count

Также не удалось найти соответствие между группами пользователей, составленным по их ролям в проектах, и между полученными в ходе кластеризации. Таким образом, **вторая гипотеза опровергается**.

Проверка **третьей гипотезы** заключается в определении связи между подсистемами, в данном случае -- между контроллерами Redmine. В работе [cite: redmine-log-2] предлагается решить эту задачу с помощью кластеризации запросов, сгруппированных по пользователям, но в результате получились всё-таки группы запросов, по которым трудно однозначно определить связь между подсистемами. Решением поставленной задачи может быть поиск корреляции между контроллерами Redmine. Корреляция определяется по квадратной матрице, элементы которой содержат количество запросов с контроллером _j_ после запроса с контроллером _i_, где _i_ и _j_ -- индексы строк и столбцов матрицы.
#cite redmine-log-2: *Вартанян А. А., Ночевнов Е. В*. Инструмент статистического анализа запросов пользователей прикладной системы для определения её доработок (на примере системы Redmine).

Метод снижения размерности матрицы позволяет получить матрицу вхождения подсистем в группы подсистем, для этого используется метод главных компонент. **почему мгк?** Каждая столбец полученной матрицы рассматривается, как группа подсистем: подсистема относится к группе, если элемент на пересечении выбранных столбца и строки имеет значение больше нуля. Возможно, что одна подсистема таким образом будет отнесена к нескольким группам, это означает, что эта подсистема нужна в нескольких группах, или, возможно, необходимо изменить входный параметр «количество подсистем».

    def controllers_matrix(logs)
      matrix = Hash.new_with_default { Hash.new_with_default(0) }
      paths = logs.select('controller, first_id').where('controller is not null and first_id is not null').group_large_dataset('first_id')
      paths.each do |first_id, path|
        next if path.blank?
        path[1..-1].each_with_index do |tuple, jk|
          ik = jk - 1
          i = path[ik]['controller']
          j = tuple['controller']
          matrix[i][j] += 1
        end
      end
      matrix
    end
    
    groups_count = 3
    matrix = controllers_matrix(Log)
    pca = calc_pca(matrix, groups_count)
    
    # теперь определим группы контроллеров
    groups = Array.new(groups_count) { [] }
    pca[:data].each_with_index do |controller, index|
      controller.each_with_index do |estimate, group_index|
        groups[group_index] << matrix.keys[index] if estimate > 0
      end
    end
    groups
    
    require 'pca'
    
    def calc_pca(matrix, components_count)
      pca = PCA.new components: components_count
      data = pca.fit_transform(matrix)
      evr = pca.explained_variance_ratio
      {data: data, evr: evr}
    end

Использование доработанного программного обеспечения для управления проектами позволило убыстрить разработку инструмента для анализа запросов пользователей и его тестирование на типовых данных. Представленный инструмент, выполненный на примере Redmine, собирает статистику запросов и определяет эксплуатационные свойства интегрируемой системы, позволяя получать и передавать информацию о её производительности и работоспособности, планировать нагрузку.


## Формирование модели оценки эффективности применения ИСУП


## Выводы

В третьей главе рассмотрены вопросы тестирования полученных результатов в ходе диссертационной работы, их внедрения на реальных предприятиях, описаны особенности внедрения каркаса ИСУП и требования к переводу результатов к промышленной эксплуатации.

Также приведены области возможного применения, оценка эффективности предлагаемых решений, полученная на основе теоретических и практических подходов, а также рекомендации по использования результатов диссертационной работы и перспективы их дальнейшего использования и развития.
