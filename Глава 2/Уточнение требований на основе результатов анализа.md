## Уточнение требований на основе результатов анализа

Разработанный инструмент сбора и анализа статистики пользовательских запросов для существующей ИСУП позволяет проверить гипотезы, которые помогут уточнить требования к функциям и технической реализации ИСУП:

*1. Функции чтения данных выполняются в 3 раза чаще функции записи, изменения и удаления данных.*

Проверка этой гипотезы позволяет определить, для каких функций при работе с данными должна быть оптимизирована система хранения и обработки данных. Если гипотеза подтверждается, то необходима оптимизация для частых операций чтения. Если гипотеза опровергается, то необходима оптимизация для частых операций записи, изменения и удаления данных. Число 3 выбрано потому, что скорость поиска записи по индексу GIN в 3 раза выше скорости поиска по индексу GiST, а скорость создания, обновления и удаления значения в индексе GIN в 3 раза ниже, чем в индексе GiST (в СУБД PostgreSQL); в данном случае GIN и GiST индексы являются примерами технически похожих решений, оптимизированных для разных функций [cite: pgsql-gin-gist].
#cite pgsql-gin-gist: PostgreSQL: Documentation: 9.1: GiST and GIN Index Types [Электронный ресурс]. URL: http://www.postgresql.org/docs/9.1/static/textsearch-indexes.html (дата обращения: 11.11.2015).

*2. Действия пользователей, имеющих сопоставимые роли в организации (исполнитель, функциональный руководитель, руководитель проекта, руководитель проектного офиса, директор), очень похожи между собой и имеют мало общего с действиями пользователей с другими уровнями полномочий.*

Для проверки этой гипотезы необходимо собрать список запросов, сгруппировать по пользователям и кластеризовать его по функциям ИСУП. При этом известны роли пользователей. Допущения: на наборе данных определяется только одна роль для каждого пользователя, количество кластеров равно количеству групп пользователей по ролям. Гипотеза будет считаться верной, если список пользователей, связанных с каждым кластером пользовательских запросов, на 90% или больше совпадает со списком пользователей, объединённых в группы по ролям.

Если гипотеза подтверждается, то необходима подстройка интерфейса ИСУП под роль пользователя.
Если гипотеза опровергается, то интерфейс ИСУП должен быть унифицированным для различных ролей пользователей.

*3. Возможно выделить группы подсистем, каждой из которых часто пользуются определённые группы людей и редко пользуются остальные.*

Если гипотеза подтверждается, то необходимо иметь возможность создать отдельные приложения (взаимодействующие между собой при необходимости) по каждой группе подсистем, которыми пользуются только некоторые определённые группы людей, что в дальнейшем позволит развивать и поддерживать эти приложения несколькими подразделениями или отдельными сотрудниками, а также снизит сложность и сузит круг решаемых приложениями задач, повысит их качество.

Если гипотеза опровергается, то нет необходимости разделять ИСУП на несколько приложений.

Проверка всех гипотез проводится на тестовом наборе данных, приведённом в источнике [cite: log-test-data].

Проверка **первой гипотезы** основывается на подсчёте количества запросов чтения данных, с одной стороны, и количества запросов записи, изменения и удаления данных, с другой стороны. При этом рассматриваются запросы в целом, без выделения конкретных операций СУБД, хранящей пользовательские запросы. Каждый запрос может приводить к выполнению нескольких различных операций СУБД. Redmine использует принцип RESTful, согласно которому запросы, выполняемые с помощью метода GET, не должны менять содержимое ресурса, к которому направлен запрос; для создания ресурса используется метод POST, для изменения -- PATCH (изменение только части ресурса) или PUT (замена ресурса целиком на основе значений, переданных в запросе), а для удаления -- метод DELETE [cite: rails-routing]. Поскольку Redmine Log сохраняет название метода запроса, то возможно произвести необходимые расчёты с помощью следующего кода:
#cite rails-routing: Rails Routing from the Outside In — Ruby on Rails Guides [Электронный ресурс]. URL: http://guides.rubyonrails.org/routing.html (дата обращения: 11.11.2015).

    method_count = Log.select(:http_method).group(:http_method).count
    read_count = method_count['GET']
    modify_methods = method_count.slice('POST', 'PUT', 'PATCH', 'DELETE')
    modify_count = modify_methods.reduce(0) { |a, e| a+e[1] }
    puts "Чтение: #{read_count}", "Запись, удаление и изменение: #{modify_count}"
    puts "Запросов на чтение в #{read_count.to_f / modify_count} раз больше"

Результат выполнения этого кода: 28533 запросов на чтение, 5928 запросов записи, изменения и удаления данных, запросов на чтение в 4,8 раз больше. **Первая гипотеза подтверждена.**

Для проверки **второй гипотезы** требуется подготовить два набора данных:

- список пользователей, сгруппированный по ролям;
- матрица использования функций, содержащая количество запросов каждого пользователя по каждой функции Redmine, причём каждая строка матрицы связана с одним пользователем.

Кластеризация матрицы использования функций проводится со следующими параметрами:

- эвклидово расстояние **почему?**;
- количество кластеров равно количеству ролей, которые есть у рассматриваемых пользователей;
- расстояние между кластерами определяется как расстояние между их центрами.

Для кластеризации используется алгоритм DIANA [cite: ai4r]. После кластеризации каждому элементу каждого кластера ставится в соответствие идентификатор пользователя, в результате получается список пользователей, объединённых в группы по функциям ИСУП, которые они использовали. Далее этот список сравнивается со списком пользователей, сгруппированным по должности: выявляются наиболее похожие группы между этими списками. Если не удаётся найти для группы из одного списка соответствующую группу из другого списка, элементы которых совпадают на 90% или больше, то рассматриваемая гипотеза опровергается.

    people_by_job = User.group_by_job # список пользователей, сгруппированный по ролям
    clusters_count = people_by_job.size
    results = Log.user_segments(clusters_count) # результаты кластеризации
    people_by_cluster = results[:users_clusters]
    
    conformity = [] # соответствие [{by_cluster: index, by_job: index}, ...]
    people_by_job.each_with_index do |group_job, job_index|
      selected_clusters = conformity.map { |line| line[:by_cluster] }
      (people_by_cluster.keys - selected_clusters).each do |cluster_index|
        group_cluster = people_by_cluster[cluster_index]
        intersection = group_job & group_cluster
        if intersection.size.to_f / group_job.size >= 0.9 && intersection.size.to_f / group_cluster.size >= 0.9
          conformity << {by_cluster: cluster_index, by_job: job_index}
          break # выход из цикла по кластерам
        end
      end
    end
    
    # если удалось найти соответствие между всеми группами,
    # то количество элементов в conformity должно быть равным clusters_count
    success = conformity.size == clusters_count

Проверка **третьей гипотезы** заключается в определении связи между подсистемами, в данном случае -- между контроллерами Redmine. В работе [cite: redmine-log-2] предлагается решить эту задачу с помощью кластеризации запросов, сгруппированных по пользователям, но в результате получились всё-таки группы запросов, по которым трудно однозначно определить связь между подсистемами. Решением поставленной задачи может быть поиск корреляции между контроллерами Redmine. Корреляция определяется по квадратной матрице, элементы которой содержат количество запросов с контроллером _j_ после запроса с контроллером _i_, где _i_ и _j_ -- индексы строк и столбцов матрицы.
#cite redmine-log-2: *Вартанян А. А., Ночевнов Е. В*. Инструмент статистического анализа запросов пользователей прикладной системы для определения её доработок (на примере системы Redmine).

Метод снижения размерности матрицы позволяет получить матрицу вхождения подсистем в группы подсистем, для этого используется метод главных компонент. **почему мгк?** Каждая столбец полученной матрицы рассматривается, как группа подсистем: подсистема относится к группе, если элемент на пересечении выбранных столбца и строки имеет значение больше нуля. Возможно, что одна подсистема таким образом будет отнесена к нескольким группам, это означает, что эта подсистема нужна в нескольких группах, или, возможно, необходимо изменить входный параметр «количество подсистем».

    def controllers_matrix(logs)
      matrix = Hash.new_with_default { Hash.new_with_default(0) }
      paths = logs.paths
      # [ [controller, ...], ... ]
      paths_controller = paths.values.map { |session_logs| session_logs.pluck(:controller) }
      paths_controller.each do |row|
        row[1..-1].each_with_index do |j, jk|
          ik = jk - 1
          i = row[ik]
          matrix[i][j] += 1
        end
      end
      matrix
    end
    
    groups_count = 3
    matrix = controllers_matrix(Log)
    pca = calc_pca(matrix, groups_count)
    
    # теперь определим группы контроллеров
    groups = Array.new(groups_count) { [] }
    pca[:data].each_with_index do |controller, index|
      controller.each_with_index do |estimate, group_index|
        groups[group_index] << matrix.keys[index] if estimate > 0
      end
    end
    groups
    
    require 'pca'
    
    def calc_pca(matrix, components_count)
      pca = PCA.new components: components_count
      data = pca.fit_transform(matrix)
      evr = pca.explained_variance_ratio
      {data: data, evr: evr}
    end

Использование доработанного программного обеспечения для управления проектами позволило убыстрить разработку инструмента для анализа запросов пользователей и его тестирование на типовых данных. Представленный инструмент, выполненный на примере Redmine, собирает статистику запросов и определяет эксплуатационные свойства интегрируемой системы, позволяя получать и передавать информацию о её производительности и работоспособности, планировать нагрузку.
