# Глава 2. Моделирование и разработка каркаса ИСУП



## Способ реализации продукта

Существующие программные продукты для управления проектами, как правило, готовы к использованию с минимальной настройкой. Однако их возможностей может быть недостаточно для реализации информационной поддержки действующих процессов в организации. Например, ни в одном из рассмотренных продуктов нет управления запросами на изменения. Это значит, что для воплощения недостающих функций необходимо разрабатывать или устанавливать дополнительные модули или дорабатывать сам продукт, создавать отдельное решение и интегрировать его с ПО для управления проектами. Но даже в этих случаях группа по внедрению УП оказывается стеснена возможностями существующего ПО, которое вынуждает организацию подстраиваться под его принципы и алгоритмы.

Альтернативным способом внедрения ПО для управления проектами является разработка программного продукта на основе действующих (или разрабатываемых в рамках КСУП) норм и процессов управления проектами в организации.

Поскольку можно выделить общую функциональность и общие требования организаций к ИСУП, занимающихся ИТ-проектами, то предлагается спроектировать и разработать программное обеспечение, реализующее основные функциональные блоки и структуры данных, характерные для управления проектами в области информационно-коммуникационных технологий.

Данное решение позволит организациям быстрее создавать ПО для управления проектами по сравнению с разработкой с чистого листа. Это решение является каркасом для ИСУП и, теоретически, может применяться для разработки ПО различных масштабов для управления проектами. Каркас в данном случае -- это основа для построения ПО, включающая в себя принципы организации структуры программного кода, входных и выходных данных, способов взаимодействия между разрабатываемым ПО и пользователями и другими информационными системами. Каркас не является готовым для использования продуктом, это технология построения ПО.

В программировании наиболее близкие к каркасу по смыслу понятия -- это библиотека и фреймворк. Библиотека является программным продуктом, который может быть подключён к разрабатываемому ПО во время компиляции или запуска, и предоставляет набор структур данных и функций согласно своему предназначению.

Фреймворк -- это программный продукт, описывающий структуру разрабатываемого ПО, накладывающий определённые ограничения на его архитектуру и возможности с целью ограждения программиста от использования нежелательных и небезопасных приёмов. В то же время, фреймворк берёт на себя большую часть работы по организации взаимодействия разрабатываемого ПО с его пользователями и другими программными продуктами, что, теоретически, позволяет сократить время разработки, концентрируясь на программировании объектов определённой предметной области.

Для реализации программного обеспечения в данной диссертационной работе выбран язык Ruby и фреймворк Rails благодаря динамической типизации языка, скорости выполнения и возможности создавать и использовать DSL (Domain Specific language, Предметно-ориентированный язык), который делает прикладной код нагляднее, короче и проще для понимания. Rails включает в себя компоненты для построения серверной части клиент-серверного приложения на основе веб-технологий, включая работу с базами данных, обработку пользовательских запросов, генерацию веб-страниц и другое [cite: what-is-rails]. Клиентской стороной клиент-серверного приложения в данном случае является браузер пользователя, отправляющий запросы и получающий ответы в виде сообщений, отдельных файлов и веб-страниц.
#cite what-is-rails: *Kehoe D*. What is Ruby on Rails? [Электронный ресурс]. URL: http://railsapps.github.io/what-is-ruby-rails.html (дата обращения: 11.10.2015).

Предлагаемый каркас расширяет и уточняет возможности Rails в области управления проектами и выполнен в виде библиотеки к нему. В среде Ruby такие библиотеки называются гемами (gem). Для установки, обновления и удаления библиотек используются программы RubyGems и Bundler.

Реализация каркаса в виде гема позволит встраивать его в различные приложения, написанные на Ruby и Rails.


## Проектирование и разработка средства анализа пользовательских запросов

В настоящее время автоматизация производственной деятельности, управление проектами, ресурсами и бизнес-процессами востребованы во многих компаниях, занимающихся разработкой и предоставлением высокотехнологичных продуктов и услуг, а так же там, где задействовано большое количество людей и оборудования. Разработчики программного обеспечения создают прикладные информационные системы для деятельности компаний, её функциональных подразделений и проектных команд, а также вспомогательные продукты, такие, как программы для управления базами данных и учётными записями [cite: vartanyan-is, стр. 31].

Бизнес-процесс -- совокупность различных функций, видов деятельности (цепочки работ), которые, вместе взятые, создают продукт или услугу, представляющие ценность для внешних или внутренних потребителей [cite: mazur-process]. Бизнес-процесс разбивается на отдельные бизнес-операции. Идея процессного управления заключается в рассмотрении функций во взаимосвязи друг с другом, т. е. в виде процессов. Процессное управление организацией основано на информационных моделях предприятия: организационно-функциональной структуры, бизнес-процессов, жизненного цикла продукта, а также моделях внешней среды. Набор таких моделей создаёт системное представление об организации  и закладывает возможность управления организацией с системных позиций.
#cite mazur-process: *Мазур И. К*. Процессный подход: эффекты и проблемы // Сборник статей Междунар. науч.-практ. конф. «Общество, наука и инновации», Уфа, 29-30 ноября 2013 г.: в 4 ч. — Ч. 1. — Уфа: РИЦ БашГУ, 2013. — C. 149-152.

Разработчикам прикладного программного обеспечения в процессе промышленной эксплуатации интересны проблемы, возникающие у пользователей в части производительности и скорости работы программы, достоверности и согласованности используемых данных. Производительность и скорость работы системы тесно связаны с прилагаемой нагрузкой со стороны пользователя. Под словом «нагрузка» мы понимаем совокупный размер данных одновременно выполняемых запросов в системе, инициируемых пользователями в системе и встроенных в систему алгоритмов обработки данных. Большая нагрузка задаёт высокие требования к производительности системы, поэтому необходимо оперативно вносить изменения в оборудование и код системы для обеспечения эксплуатационных требований к ней в компании с заранее рассчитанным количеством пользователей. Периодически может возникать потребность разделения системы на части, взаимодействующие между собой, которые можно разместить на нескольких серверах или кластерах с целью уменьшения нагрузки на каждый сервер.

Таким образом, для обеспечения качественной и оперативной работы прикладной информационной системы необходимо проанализировать работу пользователей в ней. Среди отслеживаемых параметров выделим проведённое время в системе, количество и содержимое запросов. Для анализа таких параметров предлагается использовать продукт Redmine Log, разработанный авторами с вложенными алгоритмами статистического анализа, который позволит определить критические места по использованию системы и сформулировать необходимые требования для доработки прикладной системы. Продукт Redmine Log, занимающийся сбором выполняемых пользовательских запросов, а также их анализом и передачей собранной статистики, выполнен в виде плагина Redmine.

ИТ-специалистам компании и её руководителям важно получать оперативную информацию о нагрузке системы: процент загруженности процессора и процент использования оперативной памяти серверов (это можно получить с помощью средств операционной системы, например, используя интерфейс прикладного программирования, API), и количество просмотров и одновременных пользователей в системе, общее число входов в систему за день (это рассчитывается на основе сведений, сохраняемых предлагаемым инструментом).

Важным требованием к прикладной информационной системе является её бесперебойная работоспособность в течение ограниченного времени, указанного в требованиях к системе, например, в SLA [cite: sla]. Критериями работоспособности могут быть: показатели назначения программы (каким количеством материалов и данных она может оперировать), производительности (допустимое количество обращений в секунду), целевое время отклика системы при выполнении каких-либо её функций (можно подразделить на группы: статичные, интерактивные страницы, на основе данных из других источников, с использованием аналитических функций) [cite: gasu]. Предлагаемый инструмент позволяет также отслеживать показатели производительности системы и её отклика при выполнении функций по принятым запросам.
#cite sla: *Гиббонс Пол Л*. Все, что вы хотели знать о SLA / пер. с англ. / Л. Гиббонс Пол // Директор информационной службы. — М.: Издательство "Открытые системы". — №4, 2008.
#cite gasu: Технические требования на доработку и развитие государственной автоматизированной системы «Управление» (за исключением подсистемы «Контур») и типового регионального решения [Электронный ресурс]. URL: http://gasu2.ru/sites/default/files/documents/2013/02/19/Технические_требования_ГАСУ_(2012-2014).pdf.

Вся собираемая информация сохраняется в базе данных и может быть передана в другие программы, например, можно пересылать вычисленные значения в средства мониторинга (Zabbix, Nagios, Munin и другие). Среди достоинств такой интеграции можно выделить единый интерфейс обработки и представления информации, рассылку уведомлений (email, SMS и другими способами), выполнение команд. Например, программный продукт «Zabbix» для сбора данных из внешних источников предлагает использовать пользовательские параметры (т.е. выполняемые программы на стороне источника данных, в данном случае – сервер Redmine), Zabbix Sender (программа для приёма данных) и загружаемые модули [cite: zbx-up][cite: zbx-sender][cite: zbx-lm].
#cite zbx-up:  Пользовательские параметры [Электронный ресурс]. URL: https://www.zabbix.com/documentation/2.2/ru/manual/config/items/userparameters.
#cite zbx-sender: Sender [Электронный ресурс]. URL: https://www.zabbix.com/documentation/2.2/ru/manual/concepts/sender.
#cite zbx-lm: Loadable Modules [Электронный ресурс]. URL: https://www.zabbix.com/documentation/2.2/manual/config/items/loadablemodules.

Средства мониторинга позволяют выводить на дисплей компьютера графики и таблицы с полученными значениями, а также настраивать поведение программы мониторинга на изменение значений, в т. ч. уведомлять администраторов о пиковой нагрузке.

Возможности предлагаемого инструмента по исследованию эксплуатационных свойств прикладной системы включают в себя вычисление значений ряда показателей, в т. ч., влияющих на нагрузку, таких как количество просмотров, одновременных пользователей в системе, общее число входов за день, время генерации страницы.

Поскольку на каждый запрос пользователя, принятый системой, созданный инструмент делает запись в базу данных, то количество просмотров равно количеству записей [cite: redmine-log-1]. Это справедливо и при ограничении выборки данных – фильтрации записей. Количество одновременных пользователей в прикладной информационной системе можно посчитать по количеству записей за единицу времени, например, за 1 минуту.
#cite redmine-log-1: *Ночевнов Е. В*. Разработка инструмента для анализа запросов пользователей в прикладных системах (на примере Redmine) / Е. В. Ночевнов // Вестник Астраханского государственного технического университета. Серия: Управление, вычислительная техника и информатика, 2015. — № 4. — С. 66-71.

Инструмент ассоциирует каждую запись о запросе пользователя с сессией, определяемой как последовательность запросов одного пользователя, в которой перерывы между запросами не превышают 30 минут. Это позволяет определить общее число сессий в системе. Для получения общего числа входов достаточно посчитать количество записей, с которых начались сессии, при исключении записей с повторяющимися пользователями. Входом считается именно первый запрос пользователя в течение рассматриваемого периода.

Показатели нагрузки можно сопоставить с показателями загруженности процессора, памяти или размером трафика.

Графики на рис. 1, показывающие загруженность процессора и количеству пользователей в минуту, показывают, как меняется загруженность оборудования под нагрузкой. Нагрузку при стопроцентной загруженности процессора можно считать предельно допустимой нагрузкой для тестируемого программно-аппаратного комплекса (ПАК). Таким образом, совокупность графиков на рис. 1, показывающих эксплуатационные характеристики ПАК, позволяет ответить на вопрос, достаточно ли программно-аппаратных возможностей для работы под желаемой нагрузкой, и определить допустимое количество обращений в секунду. Существуют решения для моделирования нагрузки, например, Siege [cite: siege].
#cite siege: Siege [Электронный ресурс]. URL: https://github.com/JoeDog/siege.

<p class="before_image"></p>

![график](Глава 2/Рисунки/Нагрузка.png)

Рис. 1. Графики загруженности и нагрузки

Периодически повторяющиеся запросы могут появляться из-за того, что их посылают программы-боты, которые проверяют страницы и сообщают об обновлениях. Такие запросы можно уменьшить, если блокировать их на уровне сети или сервера (если они нежелательны) или создать API для разработчиков ботов. Для получения и отправки информации не требуется генерировать страницу целиком, значит, можно уменьшить количество выполняемых операций и затрачиваемое время. Более того, сервис API можно выделить на отдельный сервер для снижения нагрузки на основном сервере. Периодически повторяющиеся запросы можно обнаружить по регулярно появляющимся запросам с совпадающими параметрам (HTTP-метод и URI), используя данные, сохраняемые предлагаемым инструментом.

Величина времени отклика системы, т. е. длительности выполнения запросов, зависит от места измерения. Например, на компьютере клиента будет наибольшее значение времени отклика, а на уровне веб-сервера и системы – меньше. Предлагаемый инструмент замеряет время генерации ответа на уровне прикладной системы, потому что он интегрируется в неё.

Созданный продукт может быть применён в текущей работе для выявления критических мест прикладной системы и формирования требований её доработки. Собранная статистика может быть полезна для разработчиков систем коллективной работы и систем управления проектами, в т. ч. для разработки средств планирования и контроля. Возможно ограничить сбор статистики по пользователям и другим критериям. Примённый подход и созданные алгоритмы могут быть встроены в другое приложение.

В настоящее время многие компании используют разнообразные прикладные системы для формализации рабочих процессов и обеспечения выполнения работ в срок и в надлежащем качестве. Руководство компаний может быть заинтересовано в том, чтобы получать актуальную информацию о том, как их сотрудники работают в таких прикладных системах, как CRM (Customer Relationship Management, система управления взаимоотношениями с клиентами), системы управления проектами, системы документооборота, системы электронного обучения, системы поддержки пользователей (Help Desk, Service Desk) и других. В системах электронного обучения и поддержки пользователей может быть интересна статистика не только по сотрудникам, но и клиентам, а также любым другим объектам, по которым собирается информация. В данной статье все учётные записи в прикладных системах рассматриваются как учётные записи пользователей, у которых есть свои различные задачи, действия, цели, свойства характера и другое. Интересной задачей является рассмотрение различных типов пользователей, определение их потребностей и доработка прикладной системы для их удовлетворения.

Вовремя замеченные проблемы в работе сотрудников с прикладными системами позволят снизить риски, связанные с невыполнением задач в срок или с несоответствующим качеством (например, из-за нечёткого разграничения ответственности, неправильной расстановки приоритетов, отсутствия организационной политики, искажения данных о выполняемой работе). На основе собранной статистики можно определить, сколько времени тратит сотрудник на выполняемые задачи, достаточно ли трудовых ресурсов и их квалификации для выполнения работ; выявить ошибки оценки бюджета, ресурсов, трудозатрат, сложности, сроков выполнения работ в прикладных системах [cite: factory-riskov].
#cite factory-riskov: *Ночевнов Е. В*. Факторы рисков ИТ-проектов // Сборник статей Междунар. науч.-практ. конф. «Общество, наука и инновации», Уфа, 29-30 ноября 2013 г.: в 4 ч. — Ч. 1. — Уфа: РИЦ БашГУ, 2013. — С. 173-176.

Данная статья описывает создание инструмента для сбора статистики и анализа запросов пользователей при работе с прикладными системами на примере Redmine — информационной системы для коллективной работы [cite: lesyuk]. Разработка велась на основе технологий и алгоритмов, разработанных в рамках положений по управлению проектами с использованием глоссария, предложенного в работе [cite: glossary]. Собранная информация может быть полезна для планирования и контроля работы пользователей системы, принятия управленческих решений и для доработки прикладной системы. Она позволит собрать ряд метрик использования системы, например: какие функции системы наиболее часто используются, сколько пользователей находились в системе в заданный период. Для этого потребуется собирать статистику посещений и определять пути пользователей в приложении (т. е. последовательности запросов каждого пользователя).
#cite lesyuk: *Lesyuk A*. Mastering Redmine. Великобритания: Packt Publishing, 2013. 366 с.
#cite glossary: *Ночевнов Е. В., Вартанян А. А*. Создание нового принципа построения глоссария для инструмента управления инфокоммуникационными проектами в экономике // Труды Северо-Кавказского филиала Московского технического университета связи и информатики. Молодежная науч.-практ. конф. СКФ МТУСИ «ИНФОКОМ-2013», Ростов-на-Дону, 22-25 апреля 2013 г. Ростов-на-Дону: СКФ МТУСИ, 2013. С. 468-470.

Созданный инструмент является плагином для Redmine. В то же время, предлагаемые подход и алгоритмы могут быть применены и для других прикладных систем. Благодаря открытому коду Redmine, его можно дорабатывать под свои нужды. Пользователи могут в этой системе создавать проекты и задачи, добавлять новости, файлы и комментарии, разрабатывать документацию, отмечать трудозатраты, заниматься планированием работ, в том числе с помощью диаграммы Ганта. Система позволяет подразделять задачи по категориям, трекерам (типам), статусам, приоритетам и др. Задачи могут быть связаны с изменениями (коммитами) в репозитории.

Разработанный плагин использует ту же среду разработки, что и Redmine (Ruby и Rails). Его код приведён в работе [cite: code-redmine-log]. Далее слово «контроллер» (controller) употребляется в том же значении, как в среде Rails: класс в программном коде, обрабатывающий запросы пользователей и отправляющий результаты обработки. Action - это функция (метод) контроллера, связанная с обработкой пользовательских запросов определённого вида. В контроллере может быть несколько таких функций, объединённых общей предметной областью или по другим признакам.
#cite code-redmine-log: *Ночевнов Е. В*. Redmine Log plugin [Электронный ресурс]. URL: https://github.com/crosspath/redmine_log (дата обращения: 29.09.2015).

Модуль анализа статистики включает в себя алгоритмы вычисления метрик и статистического анализа, в частности поиск ассоциаций (для поиска сочетаний запросов, которые чаще всего выполняются в течение одной сессии). Под словом «метрика» в статье понимается вычисляемое значение или набор значений на основе статистики, характеризующие некоторые её свойства. В качестве примеров анализа статистики в этом плагине реализованы следующие метрики:

- количество просмотров за день или заданный период (количество запросов к сайту или определённой странице);
- количество визитов за день или заданный период (количество сессий просмотров);
- количество посетителей за день или заданный период (количество пользователей, открывших сайт/страницу в заданный период);
- количество просмотров по источникам переходов (в т. ч. по подсистемам – по названию контроллера: главная страница, поиск, список проектов и т. д.);
- пути просмотра и глубина просмотра (количество страниц, открытых одним пользователем за один визит);
- наиболее посещаемые страницы (в т. ч. по сочетанию controller и action);
- страницы входа (с какой страницы начался просмотр) и выхода (какой страницей он закончился).

В качестве критериев составления путей используются следующие:

- сессия описывает запросы только одного пользователя;
- между загрузками страниц за одну сессию проходит не более 30 минут.

Это не новые метрики, а уже известные по продуктам компаний Яндекс и Google, которые предлагают решения для сбора статистики и анализа всего сайта. Недостаток этих решений в том, что им недоступен код и данные исследуемой прикладной системы, а доступно только то, что получает браузер; к тому же, эта статистика хранится в интернете (вне сервера, на котором размещён сайт), что может быть расценено как угроза безопасности.

Предлагаемое в статье решение позволяет собирать и анализировать статистику запросов, используя код и базу данных интегрируемой системы, что позволит получать и обрабатывать более детальную статистику. Вся собранная информация хранится в базе данных системы, в которую она интегрирована.

Аналогичный по приципу работы плагин для Redmine для сбора статистики о запросах пользователя redmine_access_logger предназначен только для сбора информации и не может быть использован полноценно для анализа полученной статистики [cite: Kiwamu]. Он записывает посещения в текстовом файле, что затрудняет операции группировки, поиска и т. п.; не сохраняет адрес страницы и источник перехода на текущую страницу.
#cite Kiwamu: *Kiwamu K*. redmine_access_logger [Электронный ресурс]. URL: https://github.com/kiwamu/redmine_access_logger (дата обращения: 29.09.2015).

Предлагаемый в статье плагин для сбора и анализа статистики встраивается в последовательность  обработки запросов к прикладной системе, благодаря этому в базу данных записывается каждый запрос к Redmine, кроме запросов на чтение изображений и файлов CSS и JS. В ходе установки разработанного плагина создаётся таблица logs для хранения записей об обращениях (в табл. 1 представлена структура таблицы logs), а в интерфейсе Redmine появляется параметр, включающий или отключающий сбор статистики, его можно найти на странице настроек плагина.

<p class="before_table_caption"></p>

Таблица 1. Структура таблицы logs

Атрибут |	Тип значения	| Комментарий
-------|-------|------
id	| Целое число	| Уникальный номер записи, первичный ключ
http_method	| Строка	| HTTP-метод (GET, POST и др.)
query	| Строка	| URI, кроме названия домена
parameters	| Строка	| Параметры запроса из адресной строки и отправленной формы, записанные в виде JSON
user_id	| Целое число	| Номер пользователя в системе, внешний ключ
response_code	| Целое число	| HTTP-код ответа (200, 404 и др.)
created_at	| Дата и время	| Дата и время создания записи
updated_at	| Дата и время	| Дата и время последнего изменения записи
controller	| Строка	| Название контроллера, обрабатывающего запрос
referer	| Строка	| URI источника перехода на текущую страницу
referer_controller	| Строка	| Название контроллера источника перехода на текущую страницу
first_id	| Целое число	| Номер записи в таблице logs, с которой началась текущая сессия

Для тестирования созданного плагина была подготовлена среда разработки на основе Redmine 3.0.1, Ruby 2.1, PostgreSQL 9.3.6. Для заполнения таблицы тестовыми данными были взяты реальные данные у компании, внедрившей этот инструмент. Данные были обезличены и не содержат конфиденциальную и тайную информацию [cite: log-test-data]. Тестовые данные содержат в себе запросы 121 пользователя за 7 дней, всего 34461 запись, 1767 визитов (сессий).
#cite log-test-data: *Ночевнов Е. В*. Log Test Data [Электронный ресурс]. URL: https://github.com/crosspath/log_test_data (дата обращения: 29.09.2015).

Были протестированы обе составляющие плагина: сбор статистики и анализ статистики. В базу данных записывалось каждое обращение к серверу (это можно отследить по количеству запросов в браузере и количеству строк в таблице logs, используемой для хранения статистики). Как показало тестирование, во всех случаях плагин правильно записывает данные, кроме одного: когда не запущен Redmine или СУБД (в этом случае и Redmine не работает). Сбоев не обнаружено.

Плагин также определяет и записывает дополнительную информацию о запросе: код ответа, название контроллера, обрабатывающего текущий запрос (если он был определён по адресу запроса), адрес источника (если браузер передаёт эту информацию), контроллер источника (определяется всегда, кроме случаев, когда браузер не передаёт адрес источника или когда источником не является данный запущенный экземпляр Redmine).

Для проверки алгоритмов анализа статистики сравнивались результаты, выдаваемые плагином, с результатами, полученными выполнением SQL-запросов и ручными операциями. Например, для получения количества строк в таблице можно использовать функцию SQL count; для получения путей просмотра, страниц входа и выхода можно фильтровать записи по значению столбца first_id, в нём хранится id первой записи данной сессии.

Модуль анализа статистики определяет количество просмотров по количеству записей в таблице logs (можно фильтровать выборку по датам, пользователям и т. д.). Количество визитов определяется по количеству записей, которые являются первыми в сессии. Количество посетителей считается, как количество уникальных посетителей, т. е. количество первых заходов посетителей в течение всего заданного периода.

Для определения сочетаний запросов, которые чаще всего выполняются в течение одной сессии, нужно решить задачу поиска ассоциаций. Для этого предлагается использовать алгоритм Apriori [cite: apriori][cite: code-apriori]. На вход этого алгоритма подаётся набор данных, называемых транзакциями. Каждая транзакция содержит список строк, состоящих из названия HTTP-метода и адреса (query) по каждому пользовательскому запросу за одну сессию. Алгоритм составляет набор правил, т. е. ассоциативных выражений вида _X_ => _Y_ [_support_, _confidence_], где _X_ и _Y_ — наборы элементов транзакций, _support_ — доля транзакций, содержащих _X_ и _Y_ («поддержка»), _confidence_ — доля транзакций, содержащих _X_, которые также содержат _Y_. Результатом работы алгоритма является набор правил, удовлетворяющих заданным параметрам работы алгоритма: _min_support_ (минимальное значение поддержки) и  _min_confidence_ (минимальное значение достоверности).
#cite apriori: *Stanišić P., Tomović S*. Apriori multiple algorithm for mining association rules // Information Technology And Control. — Каунас, Латвия: Kauno Technologijos Universitetas, 2008, Vol. 37. — No. 4. — С. 311-320.
#cite code-apriori: *Kazuhiro S*. Apriori::Algorithm [Электронный ресурс]. URL: https://github.com/seratch/apriori-algorithm (дата обращения: 29.09.2015).

Результаты, полученные в ходе тестирования алгоритмов анализа статистики, приведены в табл. 2-4: в табл. 2 –  список контроллеров и количество обращений по ним, в табл. 3 – самые частые запросы при тестировании, в табл. 4 – ассоциативные правила при параметрах алгоритма Apriori _min_support_ = 0,01 и _min_confidence_ = 0,6.

<p class="before_table_caption"></p>

Таблица 2. Контроллеры с наибольшим количеством обращений (на тестовых данных)

Контроллер	| Просмотры
------------|------------
issues	| 18905
screen	| 3147
my	| 1637
attachments	| 1469
projects	| 811
repositories	| 757
bulk_time_entries	| 680
account	| 666
users	| 653
search	| 463

<p class="before_table_caption"></p>

Таблица 3. Самые частые запросы (на тестовых данных; выборка по controller и action)

Действие	| Просмотры
------------|------------
issues#show	| 9541
issues#index	| 4506
screen#index	| 3174
issues#edit	| 2359
issues#update	| 2071
my#page	| 1752
issues#update_form	| 1379
attachments#thumbnail	| 954
account#login	| 769
issues#new	| 595

<p class="before_table_caption"></p>

Таблица 4. Ассоциативные правила по результатам тестирования

X (левая часть ассоциативного правила)	| Y (правая часть ассоциативного правила)	| Confidence (достоверность)
-------------------------|----------------------------|---------------------------------
POST /projects/devcawm/issues	| GET /projects/devcawm/issues/new	| 1.0
GET /issues?page=2&set_filter=0	| GET /issues?set_filter=0	| 0.97
POST /issues/bulk_update	| POST /issues/bulk_edit.js	| 0.97
POST /issues/bulk_edit.js	| POST /issues/bulk_update	| 0.97
GET /login	| GET /	| 0.95
GET /projects?level_limits[]=118&level_limits[]=117&offset=25&page=2	| GET /projects	| 0.95
POST /projects/devcawm/issues/update_form.js	| GET /projects/devcawm/issues/new	| 0.91
POST /projects/accounts/issues	| GET /projects/accounts/issues/new	| 0.89
GET /projects/devcawm/issues/new	| POST /projects/devcawm/issues/update_form.js	| 0.88
POST /projects/accounts/issues/update_form.js	| GET /projects/accounts/issues/new	| 0.82
POST /issues	| GET /issues?set_filter=0	| 0.7

<br/>

По результатам статистического анализа тестовых данных можно сделать вывод о том, что на этом наборе данных самая востребованная часть системы — это работа с задачами (issues). 9 из 11 найденных ассоциативных правил связаны с просмотром и редактированием задач.

Таким образом, для обеспечения качественной и оперативной работы прикладной информационной системы необходимо проанализировать работу пользователей в ней. Среди отслеживаемых параметров выделим проведённое время в системе, количество и содержимое запросов. Для анализа таких параметров предлагается использовать продукт Redmine Log, разработанный авторами с вложенными алгоритмами статистического анализа, который позволит определить критические места по использованию системы и сформулировать необходимые требования для доработки прикладной системы. Продукт Redmine Log, занимающийся сбором выполняемых пользовательских запросов, а также их анализом и передачей собранной статистики, выполнен в виде плагина (динамически подключаемого программного модуля) Redmine [cite: redmine-log-1].

С помощью разработанного решения можно получать дополнительную информацию о пользователях и на основе этого сегментировать их. Например, какие функции программы популярны в разных странах и в разных сегментах пользователей?

Сохраняемая информация о запросах пользователей позволяет определить, кто и какие части системы использует. Так, для разделения системы на взаимодействующие между собой сервисы можно выделить кластеры, которые состоят из часто используемых вместе подсистем, а подсистемы разных кластеров значительно реже используются вместе. Т. е. поскольку на практике используются не все функции системы, то неиспользуемые части можно изменить, удалить или выделить в отдельный продукт. Для поиска групп подсистем предлагается использовать методы кластерного анализа, а в качестве входных данных можно взять количество пользовательских запросов по контроллерам (в терминах фреймворка Rails, используемого в Redmine).

Для сегментирования пользователей и запросов используется алгоритм кластеризации DIANA [cite: ai4r]. В качестве входных данных алгоритма используется массив запросов, сгруппированный по идентификатору пользователя. После выделения кластеров определяется среднеквадратическая ошибка, показывающая разреженность кластера, и таблица расстояний между кластерами, рассчитываемая по трём характеристикам: минимальное, максимальное и среднее расстояния между парами элементов кластеров. Чем компактнее расположены элементы кластера, тем меньше ошибка. Размером кластера называют количество элементов в нём.
#cite ai4r: Ai4r [Электронный ресурс]. URL: https://github.com/SergioFierens/ai4r.

Введём обозначения для пояснения работы алгоритмов:

_i_ = 1.._n_, _n_ равно количеству подсистем,

_j_ = 1.._m_, _m_ равно количеству кластеров,

_L<sub>i</sub>_ – количество запросов к _i_-ой подсистеме,

_C<sub>ij</sub>_ – количество запросов к _i_-ой подсистеме, относящихся к _j_-ому кластеру,

_P<sub>ij</sub>_ – отношение _C<sub>ij</sub>_ к _L<sub>i</sub>_.

После кластеризации алгоритм определения групп подсистем на основе полученного разбиения и информации о запросах рассчитывает долю вхождения _P<sub>ij</sub>_ запросов по каждой подсистеме в каждый кластер, чтобы выделить группы подсистем, а алгоритм сегментирования пользователей по используемым ими функциями прикладной системы выделяет те функции, которыми они пользуются чаще пользователей из других кластеров.

Результаты, полученные в ходе тестирования алгоритма выделения подсистем, приведены в табл. 1 – размеры кластеров, среднеквадратическая ошибка по каждому кластеру, среднее расстояние до ближайшего кластера, а также подсистемы Redmine, по которым _P<sub>ij</sub>_ ≥ 70% по каждому отдельно рассматриваемому кластеру. Расчёты сделаны при параметре «количество кластеров», равным 14.

<p class="before_table_caption"></p>

Таблица 1. Результаты работы алгоритма выделения подсистем

№ кластера	| Размер кластера	| Ошибка	| Расстояние до ближайшего кластера	| Подсистемы
---------------|----------------|--------------|------------------------|----------------------
1	| 61	| 36	| 138	| enumerations, issue_statuses, settings, admin, trackers, roles, custom_fields, city
2	| 1	| 0	| 446	| -
3	| 3	| 62	| 162	| -
4	| 1	| 0	| 766	| account, welcome
5	| 1	| 0	| 802	| -
6	| 1	| 0	| 446	| -
7	| 1	| 0	| 446	| -
8	| 15	| 79	| 164	| -
9	| 1	| 0	| 301	| reports
10	| 1	| 0	| 338	| -
11	| 7	| 69	| 166	| calendars
12	| 26	| 56	| 138	| contacts, contacts_tasks, spent_time, contacts_duplicates, auto_completes, rss
13	| 1	| 0	| 166	| -
14	| 1	| 0	| 162	| -

<br/>

Подсистемы, которые не удалось соотнести с какими-либо кластерами при ограничении _P<sub>ij</sub>_ ≥ 70%:	bulk_time_entries, announcements, wiki, activities, repositories, screen, easy_issues, attachments, modal_selectors, timelog, projects, easy_documents, files, issues, users, macroview, journals, workflows, context_menus, issue_relations, my, gantts, versions, search, user_allocation_gantt, members, documents, previews, watchers.

В первом кластере в основном находятся подсистемы, связанные с изменением настроек прикладной системы, в четвёртом – страницы профиля, в девятом – просмотр отчётов, в одиннадцатом – просмотр списка своих задач в виде календаря, в двенадцатом – подсистемы, используемые при работе с контактами. В остальных кластерах не удалось выявить достаточное количество запросов, чтобы соотнести с ними какие-либо подсистемы. Подсистемы, используемые при работе с задачами и проектами, не были соотнесены с каким-то одним кластером, потому что по ним _P<sub>ij</sub>_ < 70%. Анализ тестовых данных показывает, что эта функциональность широко используется многими пользователями.

Результаты, полученные в ходе тестирования алгоритма сегментирования пользователей по используемым функциям прикладной системы, приведены в табл. 2 – размеры кластеров, среднеквадратическая ошибка по каждому кластеру, среднее расстояние до ближайшего кластера, а также наборы функций, которые чаще всего встречались в пользовательских запросах. Расчёты сделаны при параметре «количество кластеров», равным 9.

<p class="before_table_caption"></p>

Таблица 2. Результаты работы алгоритма сегментирования пользователей

№ кластера	| Размер кластера	| Ошибка	| Расстояние до ближайшего кластера	| Функции
---------------|----------------|--------------|------------------------|----------------------
1	| 107	| 80	| 318	| issues#edit, issues#index, issues#show, issues#update, issues#update_form, my#page
2	| 1	| 0	| 444	| screen#index
3	| 1	| 0	| 756	| issues#index, issues#show
4	| 1	| 0	| 777	| screen#index
5	| 1	| 0	| 756	| account#login, issues#index, issues#show, my#page
6	| 7	| 120	| 318	| issues#edit, issues#index, issues#show,  issues#update
7	| 1	| 0	| 444	| screen#index, users#save_button_settings
8	| 1	| 0	| 350	| attachments#thumbnail, issues#edit, issues#index, issues#show, issues#update, issues#update_form, my#page, users#save_button_settings
9	| 1	| 0	| 345	| issues#show, repositories#show

<br/>

Сегментирование пользователей по используемым функциям на тестовых данных не выявило значимых закономерностей, почти все выделенные функции относятся к просмотру и редактированию задач. Это может говорить об однородности входных данных – работа с задачами и проектами является основным предназначением прикладной системы Redmine и анализ тестовых данных показывает, что задачами пользовались все или почти все пользователи.

По результатам статистического анализа тестовых данных можно сделать вывод о том, что на этом наборе данных самая востребованная часть системы — это работа с задачами, и выделить её в отдельный продукт вряд ли имеет смысл. В отдельные продукты или сервисы можно выделить работу с контактами и расширенные возможности по администрированию проектов.


## Уточнение требований на основе результатов анализа

Разработанный инструмент сбора и анализа статистики пользовательских запросов для существующей ИСУП позволяет проверить гипотезы, которые помогут уточнить требования к функциям и технической реализации ИСУП:

*1. Функции чтения данных выполняются в 3 раза чаще функции записи, изменения и удаления данных.*

Проверка этой гипотезы позволяет определить, для каких функций при работе с данными должна быть оптимизирована система хранения и обработки данных. Если гипотеза подтверждается, то необходима оптимизация для частых операций чтения. Если гипотеза опровергается, то необходима оптимизация для частых операций записи, изменения и удаления данных. Число 3 выбрано потому, что скорость поиска записи по индексу GIN в 3 раза выше скорости поиска по индексу GiST, а скорость создания, обновления и удаления значения в индексе GIN в 3 раза ниже, чем в индексе GiST (в СУБД PostgreSQL); в данном случае GIN и GiST индексы являются примерами технически похожих решений, оптимизированных для разных функций [cite: pgsql-gin-gist].
#cite pgsql-gin-gist: PostgreSQL: Documentation: 9.1: GiST and GIN Index Types [Электронный ресурс]. URL: http://www.postgresql.org/docs/9.1/static/textsearch-indexes.html (дата обращения: 11.11.2015).

*2. Действия пользователей, имеющих сопоставимые роли в организации (исполнитель, функциональный руководитель, руководитель проекта, руководитель проектного офиса, директор), очень похожи между собой и имеют мало общего с действиями пользователей с ролями.*

Для проверки этой гипотезы необходимо собрать список запросов, сгруппировать по пользователям и кластеризовать его по функциям ИСУП. При этом известны роли пользователей. Допущения: на наборе данных определяется только одна роль для каждого пользователя, количество кластеров равно количеству групп пользователей по ролям. Гипотеза будет считаться верной, если список пользователей, связанных с каждым кластером пользовательских запросов, на 90% или больше совпадает со списком пользователей, объединённых в группы по ролям.

Если гипотеза подтверждается, то необходима подстройка интерфейса ИСУП под роль пользователя.
Если гипотеза опровергается, то интерфейс ИСУП должен быть унифицированным для различных ролей пользователей.

*3. Возможно выделить группы подсистем, каждой из которых часто пользуются определённые группы людей и редко пользуются остальные.*

Если гипотеза подтверждается, то необходимо иметь возможность создать отдельные приложения (взаимодействующие между собой при необходимости) по каждой группе подсистем, которыми пользуются только некоторые определённые группы людей, что в дальнейшем позволит развивать и поддерживать эти приложения несколькими подразделениями или отдельными сотрудниками, а также снизит сложность и сузит круг решаемых приложениями задач, повысит их качество.

Если гипотеза опровергается, то нет необходимости разделять ИСУП на несколько приложений.

Проверка всех гипотез проводится на тестовом наборе данных, приведённом в источнике [cite: log-test-data].

Проверка **первой гипотезы** основывается на подсчёте количества запросов чтения данных, с одной стороны, и количества запросов записи, изменения и удаления данных, с другой стороны. При этом рассматриваются запросы в целом, без выделения конкретных операций СУБД, хранящей пользовательские запросы. Каждый запрос может приводить к выполнению нескольких различных операций СУБД. Redmine использует принцип RESTful, согласно которому запросы, выполняемые с помощью метода GET, не должны менять содержимое ресурса, к которому направлен запрос; для создания ресурса используется метод POST, для изменения -- PATCH (изменение только части ресурса) или PUT (замена ресурса целиком на основе значений, переданных в запросе), а для удаления -- метод DELETE [cite: rails-routing]. Поскольку Redmine Log сохраняет название метода запроса, то возможно произвести необходимые расчёты с помощью следующего кода:
#cite rails-routing: Rails Routing from the Outside In — Ruby on Rails Guides [Электронный ресурс]. URL: http://guides.rubyonrails.org/routing.html (дата обращения: 11.11.2015).

    method_count = Log.select(:http_method).group(:http_method).count
    read_count = method_count['GET']
    modify_methods = method_count.slice('POST', 'PUT', 'PATCH', 'DELETE')
    modify_count = modify_methods.reduce(0) { |a, e| a+e[1] }
    puts "Чтение: #{read_count}", "Запись, удаление и изменение: #{modify_count}"
    puts "Запросов на чтение в #{read_count.to_f / modify_count} раз больше"

Результат выполнения этого кода: 28533 запросов на чтение, 5928 запросов записи, изменения и удаления данных, запросов на чтение в 4,8 раз больше. **Первая гипотеза подтверждена.**

Для проверки **второй гипотезы** требуется подготовить два набора данных:

- список пользователей, сгруппированный по ролям;
- матрица использования функций, содержащая количество запросов каждого пользователя по каждой функции Redmine, причём каждая строка матрицы связана с одним пользователем.

Кластеризация матрицы использования функций проводится со следующими параметрами:

- количество кластеров равно количеству ролей, которые есть у рассматриваемых пользователей;
- для измерения расстояния между элементами и центрами кластеров предлагается использовать евклидово расстояние или квадрат евклидова расстояния;
- расстояние между кластерами определяется как расстояние между их центрами (взвешенный центроидный метод), поскольку предполагаются значительные отличия в размерах кластеров [cite: cluster-methods].
#cite cluster-methods: Кластерный анализ [Электронный ресурс]. URL: http://statsoft.ru/home/textbook/modules/stcluan.html (дата обращения: 21.11.2015).

Проверка корректности выделения кластеров заключается в проведении кластеризации с использованием:

- манхэттенского расстояния и взвешенного центроидного метода;
- манхэттенского расстояния и взвешенного попарного среднего;
- евклидового расстояния или квадрата евклидова расстояния и взвешенного попарного среднего.

Для кластеризации по центроидному методу используется алгоритм KMeans [cite: ai4r], по попарному среднему -- AverageLinkage [Там же], расширенные для поддержки весовых коэффициентов при измерении расстояний. После кластеризации каждому элементу каждого кластера ставится в соответствие идентификатор пользователя, в результате получается список пользователей, объединённых в группы по функциям ИСУП, которые они использовали. Далее этот список сравнивается со списком пользователей, сгруппированным по должности: выявляются наиболее похожие группы между этими списками. Если не удаётся найти для группы из одного списка соответствующую группу из другого списка, элементы которых совпадают на 90% или больше, то рассматриваемая гипотеза опровергается.

    people_by_job = User.group_by_job # список пользователей, сгруппированный по ролям
    clusters_count = people_by_job.size
    clusterer_options = LogPlugin::Analysis::ClustererWrapper::UserSegments.new(clusters_count: clusters_count)
    results = Log.analysis.user_segments(clusterer_options) # результаты кластеризации
    people_by_cluster = results.users_clusters
    
    def maximum_deviation(size)
      (size / 4.0).ceil # округление вверх
    end
    
    def similar?(a, b)
      intersection_size = (a & b).size
      a_deviation = maximum_deviation(a.size)
      b_deviation = maximum_deviation(b.size)
      a.size - intersection_size <= a_deviation && b.size - intersection_size <= b_deviation
    end
    
    conformity = [] # соответствие [{by_cluster: index, by_job: index}, ...]
    people_by_job.each do |job, group_job|
      selected_clusters = conformity.map { |line| line[:by_cluster] }
      people_by_cluster.each_with_index do |group_cluster, cluster_index|
        next if selected_clusters.include?(cluster_index)
        group_cluster = people_by_cluster[cluster_index]
        if similar?(group_job, group_cluster)
          conformity << {by_cluster: cluster_index, by_job: job}
          break # выход из цикла по кластерам
        end
      end
    end
    
    # если удалось найти соответствие между всеми группами,
    # то количество элементов в conformity должно быть равным clusters_count
    success = conformity.size == clusters_count

Проверка **третьей гипотезы** заключается в определении связи между подсистемами, в данном случае -- между контроллерами Redmine. В работе [cite: redmine-log-2] предлагается решить эту задачу с помощью кластеризации запросов, сгруппированных по пользователям, но в результате получились всё-таки группы запросов, по которым трудно однозначно определить связь между подсистемами. Решением поставленной задачи может быть поиск корреляции между контроллерами Redmine. Корреляция определяется по квадратной матрице, элементы которой содержат количество запросов с контроллером _j_ после запроса с контроллером _i_, где _i_ и _j_ -- индексы строк и столбцов матрицы.
#cite redmine-log-2: *Вартанян А. А., Ночевнов Е. В*. Инструмент статистического анализа запросов пользователей прикладной системы для определения её доработок (на примере системы Redmine).

Метод снижения размерности матрицы позволяет получить матрицу вхождения подсистем в группы подсистем, для этого используется метод главных компонент. **почему мгк?** Каждая столбец полученной матрицы рассматривается, как группа подсистем: подсистема относится к группе, если элемент на пересечении выбранных столбца и строки имеет значение больше нуля. Возможно, что одна подсистема таким образом будет отнесена к нескольким группам, это означает, что эта подсистема нужна в нескольких группах, или, возможно, необходимо изменить входный параметр «количество подсистем».

    def controllers_matrix(logs)
      matrix = Hash.new_with_default { Hash.new_with_default(0) }
      paths = logs.paths
      # [ [controller, ...], ... ]; слишком медленно
      paths_controller = paths.values.map { |session_logs| session_logs.where('controller is not null').pluck(:controller) }
      paths_controller.each do |rows|
        rows[1..-1].each_with_index do |j, jk|
          ik = jk - 1
          i = rows[ik]
          matrix[i][j] += 1
        end
      end
      matrix
    end
    
    groups_count = 3
    matrix = controllers_matrix(Log)
    pca = calc_pca(matrix, groups_count)
    
    # теперь определим группы контроллеров
    groups = Array.new(groups_count) { [] }
    pca[:data].each_with_index do |controller, index|
      controller.each_with_index do |estimate, group_index|
        groups[group_index] << matrix.keys[index] if estimate > 0
      end
    end
    groups
    
    require 'pca'
    
    def calc_pca(matrix, components_count)
      pca = PCA.new components: components_count
      data = pca.fit_transform(matrix)
      evr = pca.explained_variance_ratio
      {data: data, evr: evr}
    end

Использование доработанного программного обеспечения для управления проектами позволило убыстрить разработку инструмента для анализа запросов пользователей и его тестирование на типовых данных. Представленный инструмент, выполненный на примере Redmine, собирает статистику запросов и определяет эксплуатационные свойства интегрируемой системы, позволяя получать и передавать информацию о её производительности и работоспособности, планировать нагрузку.


## Моделирование сценариев работы пользователей в ИСУП

Предположим, что процессы управления проектами происходят в следующем порядке:

1. Инициация проекта.
2. Составление плана управления проектом.
3. Определение содержания проекта.
4. Определение структуры декомпозиции работ.
5. Планирование закупок и ресурсов.
6. Определение работ/операций.
7. Составление расписания и бюджета проекта.
8. Составление планов коммуникаций и качества.
9. Идентификация и оценка рисков.
10. Процессы исполнения проекта.
11. Процессы контроля выполнения проекта.
12. Закрытие проекта.

Этот порядок выполнения процессов УП поможет смоделировать работу пользователей в ИСУП.

### Сценарии авторизации пользователя

### Сценарии окончания сессии пользователя

### Сценарии управления задачами и жизненного цикла задачи

### Сценарии управления проектами и жизненного цикла проекта

### Сценарии управления запросами на изменения

### Сценарии планирования задач

### Сценарии управления отчётами

### Сценарии управления коммуникациями

### Сценарии планирования ресурсов

### Сценарии управления рисками

### Сценарии управления версиями продуктов

### Сценарии управления качеством


## Техническое задание на каркас ИСУП

### Функциональные требования (9 страниц)

Объекты ИСУП.
Поддержка многопользовательского режима работы.
Роли.
Полномочия.
Жизненные циклы задач.
Фазы и жизненные циклы проектов.
Планирование задач.
Запросы на изменения.
Организационная и проектная структура.
Отчёты.
Коммуникации.
Ресурсы.
Риски, жизненный цикл рисков.
Версии продуктов.
Основные процессы и функции УП.
Управление качеством.
Маркетинг проекта.
Проектное финансирование.
Стоимость проекта.

Формы отчётов, входных и выходных документов приведены в Приложении 2.

### Прочие требования (3 страницы)

Производительность.
Доступность.
Надёжность.
Требования к рабочим местам.
Время хранения данных и архивация.
Информационная безопасность.
Аудит.
Рассылка уведомлений.


## Проектирование и разработка каркаса ИСУП

## Проектирование и разработка ИСУП

## Выводы

Во второй главе определены способы, принципы построения, используемые инструменты и технологии реализации трёх программных продуктов: инструмент регистрации и анализа пользовательских запросов в существующей прикладной системе Redmine, каркас ИСУП и созданная с его помощью ИСУП.

Статистический анализ был проведён на реальных данных с целью уточнения требований к функциональности и производительности ИСУП. Также было проведено моделирование работы и составлено техническое задание на ИСУП.
